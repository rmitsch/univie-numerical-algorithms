##############################################
# For part 1.
##############################################

# Generate random non-singular matrix.
function A = generate_random_nonsingular_matrix(n)
    A = rand(n);
end

# Calculate L, U (stored in A) and P for LU decomposition of non-singular matrix A.
function [A, P] = decompose_matrix(A, n)
    # Initialize permutation matrix P.
    P = eye(n);
     
    for k = 1:n - 1
        # Initialize permutation matrix P_k for this step.
        P_k = eye(n);

        # Fetch all elements we want to investigate to find |a_pk| >= |a_ik| -> index of maximum on or below the diagonale.
        [p_value, p_index] = max(abs(A(k:n, k)));
        # Add offset.
        p_index += k - 1;
        
        # Swap rows if there is a bigger value underneath the diagonale.
        if p_index != k
            # Swap rows.
            A([p_index, k], :) = A([k, p_index], :);
            
            # Save step in temporary permutation matrix.
            P_k(p_index, k) = 1;
            P_k(k, p_index) = 1;
            P_k(k, k) = 0;
            P_k(p_index, p_index) = 0;
            
            # Update permutation matrix.
            P = P_k * P;
        end        
        
        if A(k, k) != 0
            # Compute subdiagonal entries of L, store in A's subdiagonale instead of M.
            A(k + 1:n, k) = (A(k + 1:n, k) / A(k, k));
            
            # Apply elimination matrix (implicitly; by using values stored in A).
            A(k + 1:n, k + 1:n) -= A(k + 1:n, k) .* A(k, k + 1:n);    
        end        
    end
end

# Computes residual for comparing L * U vs. the original matrix A.
# Note: Also used for relative error, since calculation is identical.
# Both arguments (A_prime, A) have to be of the same shape.
function delta = compute_relative_delta(A_prime, A, n)
    delta = compute_1norm(A_prime - A, n) / compute_1norm(A, n);
end

# Executes code necessary to produce output for part 1 of the programming assignment.
function executePart1()
    # Apply LU factorization and compute residuals for 2^x where 3 <= x <= 10.
    problem_sizes = [8 16 32 64 128 256 512 1024 2048];
    residuals = zeros(size(problem_sizes));
    
    for i = 1:size(problem_sizes)(2)
        n = problem_sizes(i);

        # Generate random non-singular matrix of rank n.
        A = generate_random_nonsingular_matrix(n);
        # Decompose into L, U and P.
        [LU, P] = decompose_matrix(A, n);

        # Extract L and U from returned matrix.
        L = tril(LU, -1);
        U = triu(LU, 0);
        # Set diagonale of L to 1.
        L(1:1 + size(L, 1):end) = 1;

        # Compute residual.
        residuals(i) = compute_relative_delta(L * U, P * A, n);
    end

    # Plot residuals.
    figure('Position',[0, 0, 650, 250])
    semilogy(problem_sizes, residuals)
    grid on
    hold on
      legend ({
            "Residuals (for LU = PA) "
        }, "location", "eastoutside")
    title ("LU decomposition with random A", "fontsize", 16);
end

##############################################
# For parts 2 and 3.
##############################################

# Computes norm for given matrix.
function norm1 = compute_1norm(A, n)
    norm1 = 0;
    if !(isvector(A))
        for k = 1:n
            column_sum = sum(abs(A(:, k)));
            if column_sum > norm1
                norm1 = column_sum;
            end
        end
    else
        norm1 = sum(abs(A));
    end
end

# Generate random non-singular matrices, extract and return LU matrices.
# Note: These are _not_ the L and U matrix generated by the LU decomposition, but rather just upper/lower triangular
# matrices from randomly generated non-singular matrix.
function [L, U] = generate_random_nonsingular_triangular_matrices(n)
    A = rand(n);
    # Generate random matrices, extract upper and lower triangular matrices.
    # Note: Extracting lower and upper triangular matrix from a randomly generated matrix led to close-to-singular 
    # matrices - why? Hence using LU to fetch L, U, P for a randomly generated matrix A.
    [L, U, P] = lu(A);
    
    # Set diagonale of L to 1.
    #L(1:1 + size(L, 1):end) = 1;
end


# Applies forward substitution to solve Lx = b for x.
# L is a lower diagonal matrix; b a vector permuted in agreement with the permutation matrix P as generated by the LU decomposition process.
function x = apply_forward_substitution(L, b)
    x = zeros([1 length(b)]);
    
    for i = 1:length(b)
        # Calculate x_i.
        x(i) = (
            # Calculate sum to subtract by adding factors multiplied with previous results for x_(k < i).
            # Only consider if we are at least in the second row (since there aren't any previous factors in the 
            # first row).
            b(i) - sum(L(i, 1:i-1) .* x(1:i-1) * (i >= 2))
        ) / L(i, i);
    end
    
    x = transpose(x);
end

# Applies backward substitution to solve Ux = b for x.
# U is an upper diagonal matrix; b a vector permuted in agreement with the permutation matrix P as generated by the LU decomposition process.
function x = apply_backward_substitution(U, b)
    x = zeros([1 length(b)]);

    for i = length(b):-1:1
        # Calculate x_i.
        x(i) = (
            # Calculate sum to subtract by adding factors multiplied with previous results for x_(k < i).
            # Only consider if we are at least in the second row (since there aren't any previous factors in the 
            # first row).
            b(i) - sum(U(i, i+1:length(b)) .* x(i+1:length(b)) * (i <= length(b)))
        ) / U(i, i);
    end
    
    x = transpose(x);
end

# Executes code necessary to produce output for part 2 of the programming assignment.
function executePart2()
    figure('Position',[0, 0, 800, 250])
    grid on
    hold on
    
    # Apply LU factorization and compute residuals for 2^x where 3 <= x <= 10.
    problem_sizes = [8 16 32 64 128 256 512 1024 2048 4096 8192 16384];
    residuals_fw = zeros(size(problem_sizes));
    forward_errors_fw = zeros(size(problem_sizes));
    residuals_bw = zeros(size(problem_sizes));
    forward_errors_bw = zeros(size(problem_sizes));
    
    for i = 1:size(problem_sizes)(2)
        n = problem_sizes(i);

        # Generate random non-singular matrix of rank n.
        [L, U] = generate_random_nonsingular_triangular_matrices(n);
        # Determine b so that x is vector of ones.
        x = ones([n 1]);
        b_fw = L * x;
        b_bw = U * x;
        
        # Forward substitution.
        x_fw = apply_forward_substitution(L, b_fw);
        residuals_fw(i) = compute_relative_delta(L * x_fw, b_fw, n);
        forward_errors_fw(i) = compute_relative_delta(x_fw, x, n);
        
        # Backward substitution.
        x_bw = apply_backward_substitution(U, b_bw);
        residuals_bw(i) = compute_relative_delta(U * x_bw, b_bw, n);
        forward_errors_bw(i) = compute_relative_delta(x_bw, x, n);
    end

    # Plot residuals. Ignore warnings for now since otherwise we'll get some of them due to some deltas being 0.
    warning('off','all');
    semilogy(problem_sizes, residuals_fw, '1; Residuals (fwd. substitution);.-');
    semilogy(problem_sizes, forward_errors_fw, "markersize", 3, '1; Forward error (fwd. substitution);o-');
    semilogy(problem_sizes, residuals_bw, '3; Residuals (bwd. substitution);.-');
    semilogy(problem_sizes, forward_errors_bw, "markersize", 3, '3; Forward error (bwd. substitution);o-');
    legend ({
            "Residuals (fwd. substitution)", 
            "Forward error (fwd. substitution)", 
            "Residuals (bwd. substitution)", 
            "Forward error (bwd. substitution)"
        }, "location", "eastoutside")
   	title ("Fw./bw. substitution with random LU", "fontsize", 16);
end

##############################################
# For part 3.
##############################################

# Solves linear system Ax = b for x. Utilizes manual implementation of LU factorization and 
# forward/backward substitution.
function x = solve_linear_system(A, b, n)
    # 1. LU factorization.
    [LU, P] = decompose_matrix(A, n);
    
    # Extract L and U from returned matrix.
    L = tril(LU, -1);
    U = triu(LU, 0);
    # Set diagonale of L to 1.
    L(1:1 + size(L, 1):end) = 1;
    
    # 2. Solve Ly = Pb for y.
    y = apply_forward_substitution(L, P * b);
    
    # 3. Solve Ux = y for x.
    x = apply_backward_substitution(U, y);
end

# Generate test matrices S and H for part 3.
function [S, H] = generate_test_matrices_for_part3(n)
    S = rand(n) * 2 - 1;
    
    H = zeros(n);
    for i = 1:n
        H(i, :) = 1 ./ (i + (1:n) - 1);
    end
end

# Executes code necessary to produce output for part 3 of the programming assignment.
function executePart3()
    problem_sizes = [2:10, 15:5:50, 75 100 150 200 400 800 1600];
    residuals_s = zeros(size(problem_sizes));
    residuals_h = zeros(size(problem_sizes));
    forward_errors_s = zeros(size(problem_sizes));
    forward_errors_h = zeros(size(problem_sizes));
    residuals_s_octave = zeros(size(problem_sizes));
    residuals_h_octave = zeros(size(problem_sizes));
    forward_errors_s_octave = zeros(size(problem_sizes));
    forward_errors_h_octave = zeros(size(problem_sizes));    
    
    for i = 1:size(problem_sizes)(2)
        n = problem_sizes(i);
    
        # 1. Generate test matrices.
        [S, H] = generate_test_matrices_for_part3(n);

        # 2. Determine b (and consequently y) so that x = 1, 1, 1, ..., 1^T.
        x = ones([n 1]);
        b_s = S * x;
        b_h = H * x;

        # 2. Solve linear systems Sx = b and Hx = b.
        x_s = solve_linear_system(S, b_s, n);
        x_h = solve_linear_system(H, b_h, n);
        x_s_octave = S \ b_s;
        x_h_octave = H \ b_h;

        # 3. Compute accuracy measures.
        # 3. a. Compute relative residuals.
        residuals_s(i) = compute_relative_delta(S * x_s, b_s, n);
        residuals_h(i) = compute_relative_delta(H * x_h, b_h, n);
        residuals_s_octave(i) = compute_relative_delta(S * x_s_octave, b_s, n);
        residuals_h_octave(i) = compute_relative_delta(H * x_h_octave, b_h, n);
        # 3. b. Compute forward errors.
        forward_errors_s(i) = compute_relative_delta(x_s, x, n);
        forward_errors_h(i) = compute_relative_delta(x_h, x, n);
        forward_errors_s_octave(i) = compute_relative_delta(x_s_octave, x, n);
        forward_errors_h_octave(i) = compute_relative_delta(x_h_octave, x, n);        
    end
    
    # Plot metrics.
    # Sx = b
    figure('Position',[0, 0, 800, 250])
    warning('off','all');
    grid on
    hold on
    semilogy(problem_sizes, residuals_s, '1; Residual for Sx = b (manual);.-');
    semilogy(problem_sizes, forward_errors_s, "markersize", 3, '1; Forward error for Sx = b (manual);o-');
    semilogy(problem_sizes, residuals_s_octave, '3; Residuals for Sx = b (octave version);.-');
    semilogy(problem_sizes, forward_errors_s_octave, "markersize", 3, '3; Forward error for Sx = b (octave);o-');
    legend ({
            "Residual (manual)", 
            "Forward error (manual)", 
            "Residuals (octave version)", 
            "Forward error (octave)"
        }, "location", "eastoutside")    
    title ("Triang. linear system solver | Sx = b", "fontsize", 16);

    # Hx = b
    figure('Position',[0, 0, 800, 250])
    grid on
    hold on
    semilogy(problem_sizes, residuals_h, '1; Residual for Sx = b (manual);.-');
    semilogy(problem_sizes, forward_errors_h, "markersize", 3, '1; Forward error for Sx = b (manual);o-');
    semilogy(problem_sizes, residuals_h_octave, '3; Residuals for Sx = b (octave version);.-');
    semilogy(problem_sizes, forward_errors_h_octave, "markersize", 3, '3; Forward error for Sx = b (octave);o-');
    legend ({
            "Residual (manual)", 
            "Forward error (manual)", 
            "Residuals (octave version)", 
            "Forward error (octave)"
        }, "location", "eastoutside")    
    title ("Triang. linear system solver | Hx = b", "fontsize", 16);
end